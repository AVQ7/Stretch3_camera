# Copyright (c) Hello Robot, Inc.
# All rights reserved.
#
# This source code is licensed under the license found in the LICENSE file in the root directory
# of this source tree.
#
# Some code may be adapted from other open-source works with their respective licenses. Original
# license information maybe found below, if so.

import time
import timeit
from typing import List, Optional, Tuple

import numpy as np

from stretch.agent.base import ManagedOperation
from stretch.mapping.instance import Instance


class OvmmPlanOperation(ManagedOperation):
    """Execute a plan generated by the LLM planner."""

    show_instance_best_view: bool = False
    verbose: bool = False
    plan: str = ""

    def configure(
        self,
        plan: str = "",
        show_instance_best_view: bool = False,
        verbose: bool = False,
    ):
        """Configure the operation with the given keyword arguments."""
        self.plan = plan
        self.show_instance_best_view = show_instance_best_view
        self.verbose = verbose

    def can_start(self) -> bool:
        return self.plan != ""

    def pick(self, object_name: str) -> bool:
        """Pick an object."""
        self.manager.pick_object(object_name)
        return True

    def place(self, object_name: str, receptacle_name: str) -> bool:
        """Place an object."""
        self.manager.place_object(object_name, receptacle_name)
        return True

    def go_to(self, object_name: str) -> bool:
        """Go to an object."""
        print(f"Going to {object_name}")
        _, instance = self.agent.get_instance_from_text(object_name)

        if self.show_instance_best_view:
            instance.show_best_view(title=object_name)

        # Move to the instance
        return self.agent.move_to_instance(instance)

    def say(self, text: str) -> bool:
        """Say something."""
        self.manager.say(text)
        return True

    def open_cabinet(self, cabinet_name: str) -> bool:
        """Open a cabinet."""
        print("not implemented")
        return True

    def close_cabinet(self, cabinet_name: str) -> bool:
        """Close a cabinet."""
        print("not implemented")
        return True

    def wave(self) -> bool:
        """Wave."""
        n_waves = 3
        pitch = 0.2
        yaw_amplitude = 0.25
        roll_amplitude = 0.15
        lift_height = 1.0
        self.robot.switch_to_manipulation_mode()

        first_pose = [0.0, lift_height, 0.05, 0.0, 0.0, 0.0]

        # move to initial lift height
        first_pose[1] = lift_height
        self.robot.arm_to(first_pose, blocking=True)

        # generate poses
        wave_poses = np.zeros((n_waves * 2, 6))
        for i in range(n_waves):
            j = i * 2
            wave_poses[j] = [0.0, lift_height, 0.05, -yaw_amplitude, pitch, -roll_amplitude]
            wave_poses[j + 1] = [0.0, lift_height, 0.05, yaw_amplitude, pitch, roll_amplitude]

        # move to poses w/o blocking to make smoother motions
        for pose in wave_poses:
            self.robot.arm_to(pose, blocking=False)
            time.sleep(0.375)

        self.robot.switch_to_navigation_mode()

    def get_detections(self, **kwargs) -> List[Instance]:
        """Get the current detections."""
        instances = self.agent.voxel_map.get_instances()

        # Consider only instances close to the robot
        robot_pose = self.robot.get_base_pose()
        close_instances = []

        for instance in instances:
            instance_pose = instance.get_best_view().cam_to_world
            distance = np.linalg.norm(robot_pose[:2] - instance_pose[:2])
            if distance < 2.0:
                close_instances.append(instance)

        close_instances_names = [
            self.agent.semantic_sensor.get_class_name_for_id(instance.category_id)
            for instance in close_instances
        ]

        return close_instances_names

    def run(self) -> None:
        """Execute a plan function given as a string."""
        try:
            exec(self.plan)

            return True
        except Exception as e:
            print(f"Failed to execute plan: {e}")
            return False
